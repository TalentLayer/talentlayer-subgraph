enum ServiceStatus {
  Filled
  Confirmed
  Rejected
  Finished
  Opened
}

enum PaymentType {
  Release
  Reimburse
}

type Service @entity {
  id: ID! # service id
  createdAt: BigInt! # timestamp of block creation
  updatedAt: BigInt! # timestamp of the last change
  status: ServiceStatus! # service status
  buyer: User # service buyer
  seller: User # service seller
  sender: User # user that created the service (buyer or seller)
  recipient: User # other participating user (seller or buyer)
  transaction: Transaction @derivedFrom(field: "service") # transaction associated with this service
  proposals: [Proposal!] @derivedFrom(field: "service") # proposals for this service
  platform: Platform # Platform on which service was created
  cid: String
  description: ServiceDescription @derivedFrom(field: "service")
}

type ServiceDescription @entity {
  id: ID! #cid
  service: Service!
  title: String
  about: String
  startDate: BigInt
  expectedEndDate: BigInt
  keywords: [Keyword!] #keywords
  keywords_raw: String #lowercase keywords in raw format
  rateToken: String
  rateAmount: BigInt
}

type Keyword @entity {
  id: ID! #Keyword
  # Derived from does not currently work because of open issue with duplicated entities.
  # Reason: createOrGetKeyword creates duplicated keywords from file data source (ipfs-data.ts)
  # https://github.com/graphprotocol/graph-node/issues/4087
  # serviceDescription: ServiceDescription @derivedFrom(field: "keywords")
}

type Review @entity {
  id: ID! # review nft id
  service: Service! # service this review is for
  createdAt: BigInt!
  to: User! # reviewed user
  platform: Platform # Platform on which review nft was minted
  rating: BigInt
    description: ReviewDescription @derivedFrom(field: "review")
}

type ReviewDescription @entity {
  id: ID!
  content: String
  review: Review
}

type Token @entity {
  id: ID! # token id
  address: Bytes! # token entity
  symbol: String! # token code
  name: String! # token name
  decimals: BigInt! # token decimals
}

type User @entity {
  id: ID! # user nft id
  handle: String! # handle of user
  createdAt: BigInt!
  updatedAt: BigInt!
  platform: Platform # Platform on which user nft was minted
  numReviews: BigInt! # number of reviews user has received
  address: String! # wallet address of user
  rating: BigDecimal! # average rating from reviews user has received
  reviews: [Review!] @derivedFrom(field: "to") # reviews of user
  buyerServices: [Service!] @derivedFrom(field: "buyer") # services user is an buyer for
  sellerServices: [Service!] @derivedFrom(field: "seller") # services user is an seller for
  totalGains: [UserGain!] @derivedFrom(field: "user")
  cid: String #cid of the description
  description: UserDescription @derivedFrom(field: "user")
}

type UserDescription @entity {
  id: ID! #cid
  title: String
  about: String
  skills_raw: String
  skills: [Keyword!]
  timezone: BigInt
  headline: String
  country: String
  picture: String #url
  user: User!
}

enum ProposalStatus {
  Pending
  Validated
  Rejected
}

type Proposal @entity {
  id: ID! # concatenation of serviceId + seller TalentLayerId
  service: Service! # service entity
  createdAt: BigInt! # timestamp of block creation
  updatedAt: BigInt! # timestamp of the last change
  status: ProposalStatus! # Proposal status
  seller: User # Proposal seller
  rateToken: Token! # Rate token entity
  rateAmount: BigInt # Rate amount
  cid: String # cid of the description
  platform: Platform # Platform on which proposal was created
  description: ProposalDescription @derivedFrom(field: "proposal") #Proposals that the description describes.
}

type ProposalDescription @entity {
  id: ID! #Cid
  proposal: Proposal!
  startDate: BigInt
  title: String
  about: String
  expectedHours: BigInt
}

#NB: Payment sender will always be the Escrow Contract
type Payment @entity {
  id: ID! # autogenerated id
  createdAt: BigInt # timestamp of block creation
  service: Service! # service entity
  amount: BigInt! # payment amount
  rateToken: Token! # Rate token entity
  paymentType: String # Whether the payment is a release or a reimbursement
  transactionHash: String # Transaction hash of the transfer
  transaction: Transaction! # transaction entity
}

enum TransactionStatus {
  NoDispute
  WaitingSender
  WaitingReceiver
  DisputeCreated
  Resolved
}

#TODO remove "rate" from the fields. Is it a rate or a fee?
type Transaction @entity {
  id: ID! # transaction id
  sender: User # sender of the transaction
  receiver: User # receiver of the transaction
  token: Token! # token entity
  amount: BigInt! # amount
  service: Service # service entity
  protocolEscrowFeeRate: Int! # fee paid to the protocol
  originServiceFeeRate: Int! # Fee asked by the platform which created the service
  originValidatedProposalFeeRate: Int! # Fee asked by the platform on which the proposal was validated
  disputeId: BigInt # id of the dispute if exists
  senderFee: BigInt! # fees paid by the sender for arbitration
  receiverFee: BigInt! # fees paid by the receiver for arbitration
  lastInteraction: BigInt! # timestamp of the last interaction by parties with the dispute
  status: TransactionStatus! # status of the payment
  arbitrator: Bytes! # address of the arbitrator contract
  arbitratorExtraData: Bytes! # extra data for the arbitrator
  arbitrationFeeTimeout: BigInt! # timeout for the arbitration fee to be paid
  ruling: BigInt # ruling of the arbitrator on the dispute
  evidences: [Evidence!] @derivedFrom(field: "transaction") # proposals for this service
  metaEvidenceUri: String! # uri of the dispute metadata
  payments: [Payment!] @derivedFrom(field: "transaction") # payments related to this transaction
}

type Evidence @entity {
  id: ID! # autogenerated id
  transaction: Transaction! # transaction entity
  createdAt: BigInt! # Timestamp of block creation
  party: User! # party that submitted the evidence
  uri: String! # metadata URI of evidence
}

type Platform @entity {
  id: ID! # platform id
  address: Bytes! # wallet address of platform owner
  name: String! # name of the platform
  createdAt: BigInt!
  updatedAt: BigInt!
  feePayments: [FeePayment!] @derivedFrom(field: "platform") # Platform-related fee payments
  totalPlatformGains: [PlatformGain!] @derivedFrom(field: "platform") # Platform-related total gains per token
  feeClaims: [FeeClaim!] @derivedFrom(field: "platform") # Platform-related fee claims
  originServiceFeeRate: Int! # Fee asked by the platform which created the service
  originValidatedProposalFeeRate: Int! # Fee asked by the platform on which the proposal was validated
  servicePostingFee: Int! # Flat fee asked by the platform to post a service
  proposalPostingFee: Int! # Flat fee asked by the platform to post a proposal
  arbitrator: Bytes! # address of the arbitrator contract
  arbitratorExtraData: Bytes! # extra data for the arbitrator
  arbitrationFeeTimeout: BigInt! # timeout for the arbitration fee to be paid
  cid: String #cid of description
  description: PlatformDescription @derivedFrom(field: "platform")
}

type PlatformDescription @entity {
  id: ID! #cid
  about: String #text
  website: String #url
  logo: String #url
  platform: Platform!
}

enum FeeType {
  Platform
  OriginPlatform
}

type FeePayment @entity {
  id: ID! # autogenerated id
  createdAt: BigInt # timestamp of block creation
  platform: Platform # platform entity
  service: Service # service entity
  type: FeeType! # fee type
  token: Token # token entity
  amount: BigInt # platform fee
}

type FeeClaim @entity {
  id: ID! # autogenerated id
  createdAt: BigInt # timestamp of block creation
  platform: Platform # platform entity
  token: Token # token entity
  amount: BigInt! # claim amount
  transactionHash: String # Transaction hash of the transfer
}

type PlatformGain @entity {
  id: ID! # concatenation of platformId + token entity
  platform: Platform # platform entity
  token: Token # token entity
  totalOriginPlatformFeeGain: BigInt! # total Origin Platform gain
  totalPlatformFeeGain: BigInt! # total Platform gain
}

type UserGain @entity {
  id: ID! # concatenation of userId + token entity
  user: User
  token: Token # token entity
  totalGain: BigInt! # total User gain
}

type Protocol @entity {
  id: ID! # autogenerated id
  userMintFee: BigInt! # protocol fee for minting a TL id
  platformMintFee: BigInt! # protocol fee for minting a platform id
  protocolEscrowFeeRate: Int! # protocol fee for each escrow transaction (percentage, per 10,000)
  totalMintFees: BigInt! # total mint fees collected
  minArbitrationFeeTimeout: BigInt! # minimum timeout to pay the arbitration fee
}

# type _Schema_ @fulltext (
#   name: "serviceDescriptionSearchRank"
#   language: en
#   algorithm: proximityRank
#   include: [
#     { entity: "ServiceDescription", fields: [
#       { name: "title" },
#       { name: "keywords_raw" }
#     ]}]
# )
